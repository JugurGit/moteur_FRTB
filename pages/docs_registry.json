{
  "equity.py": {
    "title": "Equity — FRTB SA / SBM (Black-Scholes call) : Delta + Vega + Curvature",
    "tags": ["FRTB", "SA", "SBM", "Equity", "BlackScholes", "Delta", "Vega", "Curvature", "Buckets"],
    "summary": "- **Rôle** : calcule le capital **Equity** selon **FRTB SA / SBM** pour un portefeuille de **calls européens** (par buckets), avec les trois composantes **Delta**, **Vega** et **Curvature**.\n- **Utilisation dans le projet** : appelé par la couche résultats / moteur principal pour produire `K_final` et des détails par bucket (utile pour affichage UI et exports).\n- **Objets clés** :\n  - `EquityConfig` : paramètres de risk weights et corrélations (RW spot/repo/curv par bucket, `rho_spot_repo_med`, `gamma_inter_bucket_med`, `rw_vega`).\n  - `bs_call_price_delta_vega(...)` : pricing BS + greeks (price, delta, vega) utilisés pour les sensibilités.\n  - `equity_sbm(trades, cfg, verbose)` : pipeline complet (metrics → Delta SBM → Vega SBM → Curvature SBM → max(low/med/high)).",
    "usage": "```python\nfrom frtb.equity import equity_sbm, EquityConfig\nfrom portfolio import EquityCallTrade\n\ntrades = [\n    EquityCallTrade(name=\"EQ1\", bucket=7, N=1e6, S0=100, K=105, T=1.0, r=0.02, q_repo=0.01, sigma=0.20),\n    EquityCallTrade(name=\"EQ2\", bucket=8, N=8e5,  S0=50,  K=55,  T=2.0, r=0.015, q_repo=0.008, sigma=0.25),\n]\n\ncfg = EquityConfig(\n    delta_rw={\n        7: {\"spot\": 0.30, \"repo\": 0.25, \"curv\": 0.30},\n        8: {\"spot\": 0.32, \"repo\": 0.26, \"curv\": 0.32},\n    },\n    rho_spot_repo_med=0.40,\n    gamma_inter_bucket_med=0.15,\n    rw_vega=0.7778,\n)\n\nout = equity_sbm(trades, cfg, verbose=True)\nprint(out[\"K_final\"], out[\"totals\"])  # low/medium/high\nprint(out[\"bucket_delta\"].keys(), out[\"bucket_curv\"].keys())\n```"  
    }, 
    "portfolio.py": {
    "title": "Portfolio — dataclasses de trades (Equity / GIRR)",
    "tags": ["FRTB", "Portfolio", "CSV", "Dataclasses", "Equity", "GIRR", "Swap", "Bond"],
    "summary": "- **Rôle** : définit les structures de données du **portefeuille** (trades Equity Calls, GIRR Swaps, GIRR Bonds).\n- **Utilisation dans le projet** : utilisé par l’UI (page Portfolio / upload) ou le moteur principal pour instancier les trades typés à partir d’un fichier CSV.\n- **Objets clés** :\n  - `EquityCallTrade`, `SwapTrade`, `BondTrade` : dataclasses “trade-level” contenant les champs nécessaires au pricing/sensi.\n  - `Portfolio` : conteneur structuré (`equity_calls`, `girr_swaps`, `girr_bonds`).",
    "usage": "```python\nfrom frtb.portfolio import load_portfolio_csv\n\np = load_portfolio_csv(\"portfolio.csv\")\nprint(len(p.equity_calls), len(p.girr_swaps), len(p.girr_bonds))\n\n# Exemple d'accès\nif p.equity_calls:\n    t0 = p.equity_calls[0]\n    print(t0.name, t0.bucket, t0.S0, t0.sigma)\n```",
    "notes": "- **Format attendu du CSV** : une ligne par trade, avec une colonne `type` parmi :\n  - `EQUITY_CALL` : `name,bucket,N,S0,K,T,r,q_repo,sigma`\n  - `GIRR_SWAP`   : `name,ccy,notional,maturity,receive_fixed` (où `receive_fixed` vaut `0/1`)\n  - `GIRR_BOND`   : `name,ccy,notional,coupon_rate,maturity`.\n- **Conversion bool swap** : `receive_fixed=bool(int(row[\"receive_fixed\"]))` → le CSV doit contenir `0` ou `1` (sinon ValueError)."
    }, 
    "curves.py": {
    "title": "Courbes zéro-coupon — interpolation linéaire, DF, et bump sur nœud",
    "tags": ["FRTB", "GIRR", "Curve", "ZeroRates", "DiscountFactor", "Interpolation", "BumpAndReprice"],
    "summary": "- **Rôle** : implémente une courbe de taux zéro simple (`ZeroCurve`) avec **interpolation linéaire** des zéros, calcul des **discount factors** et une méthode de **bump** sur un nœud exact.\n- **Utilisation dans le projet** : utilisée par les pricers GIRR (bonds/swaps) pour obtenir `z(t)` et `DF(t)`, et par les sensibilités **bump-and-reprice** via `bumped(...)`.\n- **Objets clés** :\n  - `lin_interp(...)` : interpolation linéaire robuste (gère le cas `x0==x1`).\n  - `ZeroCurve(tenors, zeros)` : dataclass immuable (tuples) représentant une courbe zéro.\n    - `z(t)` : zéro interpolé à maturité `t`.\n    - `df(t)` : facteur d’actualisation `exp(-z(t)*t)`.\n    - `bumped(bump_t, bump_size)` : retourne une **nouvelle** courbe avec un bump sur un tenor **exactement présent**.",
    "usage": "```python\nfrom frtb.curves import ZeroCurve\n\ncurve = ZeroCurve(\n    tenors=(1.0, 2.0, 5.0, 10.0),\n    zeros=(0.02, 0.022, 0.025, 0.028),\n)\n\n# Interpolation\nprint(curve.z(3.0))   # zéro interpolé entre 2Y et 5Y\nprint(curve.df(5.0))  # DF(5Y)\n\n# Bump-and-reprice sur un nœud exact\ncurve_up = curve.bumped(bump_t=5.0, bump_size=1e-4)  # +1bp sur le zéro 5Y\nprint(curve_up.z(5.0), curve.z(5.0))\n```"    }, 
  
    "market.py": {
    "title": "Market snapshot — FX + courbes par devise + conversion vers la devise de reporting",
    "tags": ["FRTB", "MarketData", "FX", "ZeroCurve", "GIRR", "ReportingCurrency"],
    "summary": "- **Rôle** : regroupe un « snapshot » de marché minimal :\n  - devise de reporting,\n  - taux de change FX,\n  - courbes de taux zéro (`ZeroCurve`) par devise.\n- **Utilisation dans le projet** : sert de conteneur unique pour que les modules GIRR (swaps/bonds) puissent :\n  - récupérer la courbe d’une devise (`curves[ccy]`) pour `z(t)`/`DF(t)`,\n  - convertir des PV/sensis d’une devise vers la devise de reporting via `convert(...)`.\n- **Objets clés** :\n  - `Market(reporting_ccy, fx, curves)` : dataclass immuable.\n  - `convert(amount, from_ccy, to_ccy)` : conversion simple via la map FX `(from,to) -> rate`.",
    "usage": "```python\nfrom frtb.curves import ZeroCurve\nfrom frtb.market import Market\n\ncurves = {\n    \"EUR\": ZeroCurve((1.0, 2.0, 5.0), (0.02, 0.022, 0.025)),\n    \"USD\": ZeroCurve((1.0, 2.0, 5.0), (0.03, 0.032, 0.035)),\n}\n\nmkt = Market(\n    reporting_ccy=\"EUR\",\n    fx={\n        (\"USD\", \"EUR\"): 0.92,\n        (\"EUR\", \"USD\"): 1.0 / 0.92,\n    },\n    curves=curves,\n)\n\npv_usd = 1_000_000\npv_eur = mkt.convert(pv_usd, \"USD\", \"EUR\")\nprint(pv_eur)\n\n# Accès à une courbe\nDF_5Y_USD = mkt.curves[\"USD\"].df(5.0)\nprint(DF_5Y_USD)\n```"  }, 
    
    "girr.py": {
    "title": "GIRR — FRTB SA / SBM (Delta) via bump-and-reprice pour Swaps & Bonds + agrégation intra/inter-bucket",
    "tags": ["FRTB", "GIRR", "SBM", "Delta", "bump-and-reprice", "ZeroCurve", "Market", "Swaps", "Bonds", "Correlation"],
    "summary": "- **Rôle** : calcule le capital **GIRR Delta (SBM)** en :\n  1) pricant swaps/bonds sur une `ZeroCurve`,\n  2) estimant des **sensibilités** par **bump-and-reprice** sur les nœuds de courbe (`rw_by_tenor`),\n  3) appliquant les **risk weights** (WS),\n  4) agrégeant **intra-bucket** (corrélation entre tenors) puis **inter-bucket** (corrélation entre devises).\n- **Utilisation dans le projet** : appelé par le moteur principal pour la partie GIRR :\n  - `sensitivities_swaps(...)` / `sensitivities_bonds(...)` → sensibilités bucketées par devise et tenor,\n  - `girr_delta_sbm(...)` → capital GIRR Delta final (max low/med/high).\n- **Objets clés** :\n  - Pricing : `par_swap_rate`, `pv_swap`, `pv_bond`.\n  - Config : `GirrConfig` (RW, bump, règles scénario & corrélation).\n  - Sensis : `bump_and_reprice_sens` (générique swaps/bonds).\n  - Corrélations : `corr_matrix_for_tenors` + `rho_rule`.\n  - Agrégation : `girr_delta_sbm` + `inter_bucket`.",
    "usage": "```python\nfrom frtb.curves import ZeroCurve\nfrom frtb.market import Market\nfrom frtb.portfolio import SwapTrade, BondTrade\nfrom frtb.girr import GirrConfig, sensitivities_swaps, sensitivities_bonds, girr_delta_sbm\n\n# --- Market (curves + FX)\ncurves = {\n    \"EUR\": ZeroCurve((1.0, 2.0, 5.0, 10.0), (0.02, 0.022, 0.025, 0.028)),\n    \"USD\": ZeroCurve((1.0, 2.0, 5.0, 10.0), (0.03, 0.032, 0.035, 0.038)),\n}\n\nmkt = Market(\n    reporting_ccy=\"EUR\",\n    fx={(\"USD\", \"EUR\"): 0.92, (\"EUR\", \"USD\"): 1.0/0.92},\n    curves=curves,\n)\n\n# --- Trades\nswaps = [\n    SwapTrade(name=\"IRS_EUR_5Y\", ccy=\"EUR\", notional=10e6, maturity=5, receive_fixed=False),\n    SwapTrade(name=\"IRS_USD_3Y\", ccy=\"USD\", notional=8e6, maturity=3, receive_fixed=True),\n]\n\nbonds = [\n    BondTrade(name=\"BOND_EUR_3Y\", ccy=\"EUR\", notional=5e6, coupon_rate=0.03, maturity=3),\n]\n\n# --- Config GIRR\ncfg = GirrConfig(\n    rw_by_tenor={1.0: 0.0025, 2.0: 0.0030, 5.0: 0.0035, 10.0: 0.0040},\n    specified_currency_reduction=False,\n    bump_bp=1e-4,\n    gamma_inter_ccy_med=0.5,\n    scenario_rule=\"lowmedhigh\",\n    rho_rule=\"exp_absdiff\",\n    rho_param=0.05,\n)\n\n# --- Sensis (en devise de reporting) puis capital GIRR Delta\nsens_sw = sensitivities_swaps(swaps, mkt, cfg, verbose=True)\nsens_bo = sensitivities_bonds(bonds, mkt, cfg, verbose=True)\n\n# On peut sommer les sensis swaps+bonds avant agrégation\nbucket_sens = sens_sw\nfor ccy, d in sens_bo.items():\n    bucket_sens.setdefault(ccy, {T: 0.0 for T in cfg.rw_by_tenor})\n    for T, v in d.items():\n        bucket_sens[ccy][T] += v\n\nres = girr_delta_sbm(bucket_sens, cfg, verbose=True)\nprint(res[\"K_final\"], res[\"totals\"])\n```",
    "notes": "- **Bump-and-reprice** : `s_k ≈ (PV_bumped - PV0) / bump_bp`, puis conversion FX vers `reporting_ccy`. \n -**Scénarios low/med/high** : le module calcule `K_b` et `K_total` pour chaque scénario, puis prend le max.\n- **Specified currency reduction** : si activé, les RW sont divisés par \\(\\sqrt{2}\\) (règle simplifiée) avant calcul des WS.\n- **Sorties utiles** : `girr_delta_sbm` renvoie aussi `WS`, `S` et `Kb`."
  }, 
    "demo.py": {
    "title": "Données de démo — Market (courbes+FX), Configs (Equity/GIRR) et Portfolio exemple",
    "tags": ["FRTB", "demo", "Market", "ZeroCurve", "FX", "EquityConfig", "GirrConfig", "Portfolio", "fixtures"],
    "summary": "- **Rôle** : centralise des **fixtures de démonstration** (marché, configs, portefeuille) pour tester rapidement le moteur FRTB et alimenter l’UI Streamlit (boutons *Reset → Demo*).\n- **Utilisation dans le projet** :\n  - `demo_market()` construit un `Market` (devise de reporting, FX, courbes swap) + renvoie aussi un tuple de données de courbe « bonds » (tenors, z_eur_bond, z_usd_bond) pour les écrans/plots.\n  - `demo_equity_config()` fournit une `EquityConfig` minimaliste (2 buckets) pour Equity Delta/Vega/Curvature.\n  - `demo_girr_cfg_swaps()` et `demo_girr_cfg_bonds()` fournissent deux `GirrConfig` (RW, bump, règles de scénarios/corrélations) pour illustrer des réglages différents.\n  - `demo_portfolio()` renvoie un `Portfolio` jouet (2 equity calls, 2 swaps, 2 bonds) conçu pour déclencher inter-bucket et multi-devises.\n- **Objets clés** : `Market`, `ZeroCurve`, `EquityConfig`, `GirrConfig`, `Portfolio` et trades associés (`EquityCallTrade`, `SwapTrade`, `BondTrade`).",
    "usage": "```python\nfrom frtb.demo import (\n    demo_market,\n    demo_equity_config,\n    demo_girr_cfg_swaps,\n    demo_girr_cfg_bonds,\n    demo_portfolio,\n)\n\n# --- marché + courbes démo\nmkt, (tenors, z_eur_bond, z_usd_bond) = demo_market()\n\n# --- configs démo\neq_cfg = demo_equity_config()\nsw_cfg = demo_girr_cfg_swaps()\nbo_cfg = demo_girr_cfg_bonds()\n\n# --- portefeuille démo\np = demo_portfolio()\n\nprint(mkt.reporting_ccy)\nprint(len(p.equity_calls), len(p.girr_swaps), len(p.girr_bonds))\n```",
    "notes": "- **Configs** : l’exemple illustre volontairement deux styles GIRR :\n  - Swaps : `scenario_rule=\"lowmedhigh\"`, `rho_rule=\"exp_absdiff\"`, et `specified_currency_reduction=True`.\n  - Bonds : `scenario_rule=\"basel_scale\"`, `rho_rule=\"basel_tenor\"`, et `specified_currency_reduction=False`.\n- **Portfolio** :\n  - Equity : 2 trades short call dans deux buckets (7 et 8) pour provoquer une agrégation inter-bucket.\n  - GIRR : EUR/USD pour déclencher une agrégation inter-devise et la conversion FX vers la devise de reporting.\n- **But** : ces données ne sont pas « marché réel », elles servent à obtenir des résultats reproductibles (tests, UI, exemples)."
  }, 
    "engine.py": {
    "title": "Moteur FRTB — orchestration Equity (Delta/Vega/Curvature) + GIRR Delta (Swaps/Bonds) + résumé",
    "tags": ["FRTB", "engine", "orchestration", "Equity", "GIRR", "SBM", "bump&reprice", "Streamlit"],
    "summary": "- **Rôle** : fournit une façade unique `FRTBEngine.run()` qui exécute l’ensemble du calcul **FRTB SA / SBM** du projet :\n  - **Equity** : `equity_sbm()` (Delta + Vega + Curvature) sur `Portfolio.equity_calls`.\n  - **GIRR Swaps** : calcule d’abord les **sensibilités bump&reprice** (`sensitivities_swaps`) puis agrège via `girr_delta_sbm()`.\n  - **GIRR Bonds** : idem avec `sensitivities_bonds` + `girr_delta_sbm()`, avec option d’override de courbes.\n- **Utilisation dans le projet** : point d’entrée utilisé par l’UI (run/re-run, verbose on/off), et par les scripts de test/démo pour obtenir un dictionnaire de résultats structuré par risk class.\n- **Objets clés** :\n  - `FRTBEngine` : contient `Market` + `EquityConfig` + deux `GirrConfig` (swaps et bonds).\n  - `run(...)` : renvoie `{ \"equity\": ..., \"girr_swaps\": ..., \"girr_bonds\": ... }` et imprime un résumé si `verbose=True`.",
    "usage": "```python\nfrom frtb.demo import (\n    demo_market, demo_equity_config, demo_girr_cfg_swaps, demo_girr_cfg_bonds, demo_portfolio\n)\nfrom frtb.engine import FRTBEngine\n\nmkt, bond_override = demo_market()\nengine = FRTBEngine(\n    market=mkt,\n    equity_cfg=demo_equity_config(),\n    girr_cfg_swaps=demo_girr_cfg_swaps(),\n    girr_cfg_bonds=demo_girr_cfg_bonds(),\n)\n\np = demo_portfolio()\n\n# Run standard\nout = engine.run(p, verbose=True)\nprint(out[\"equity\"][\"K_final\"], out[\"girr_swaps\"][\"K_final\"], out[\"girr_bonds\"][\"K_final\"])\n\n# Run bonds avec override de courbes (tenors + z_eur_bond + z_usd_bond)\nout2 = engine.run(p, bond_curves_override=bond_override, verbose=False)\nprint(out2[\"girr_bonds\"][\"K_final\"])\n```",
    "notes": "- **Résumé total** : le « Total (somme) » affiché est une **somme simple** des trois K (pas une agrégation réglementaire cross-risk-class).\n- **Verbose** : `verbose=True` déclenche beaucoup de `print()` provenant de `equity_sbm` et `girr_delta_sbm` (utile en mode pédagogique / debug)."
  }, 
    "history_db.py": {
    "title": "Historique des runs ",
    "tags": ["history", "sqlite", "persistence", "runs", "snapshot", "Streamlit", "audit", "reproducibility"],
    "summary": "- **Rôle** : fournit une mini-couche d’accès SQLite pour **enregistrer** et **relire** l’historique des exécutions (runs) de l’app :\n   - résultats (K_eq/K_sw/K_bo/K_total, results_json),\n - logs (logs_txt) et erreurs (error_txt).\n- **Utilisation dans le projet** : alimenter la page *History / Results* : lister les runs, ouvrir un run, restaurer un run (recharger portfolio/market/configs), supprimer un run.\n- **Objets clés** :\n  - `init_db()` : crée la table `runs` et les index si besoin.\n  - `insert_run(rec)` : insère un enregistrement complet et renvoie l’`id`.\n  - `list_runs(...)` : renvoie une liste de runs (champs résumés) pour affichage.\n  - `get_run(id)` : renvoie toutes les colonnes (snapshot, résultats, logs...).\n  - `delete_run(id)` / `clear_all()` : nettoyage.",
    "usage": "```python\nimport json\nfrom history_db import insert_run, list_runs, get_run\n\n# Exemple minimal d’insertion\nrun_id = insert_run({\n    \"created_at_utc\": \"2026-01-05T00:30:00Z\",\n    \"created_at_local\": \"2026-01-05 01:30:00\",\n    \"status\": \"ok\",\n    \"k_eq\": 12345.0,\n    \"k_sw\": 6789.0,\n    \"k_bo\": 111.0,\n    \"k_total\": 19245.0,\n    \"portfolio_csv\": \"type,name,...\\n...\",\n    \"snapshot_json\": json.dumps({\"market\": {...}, \"configs\": {...}}),\n    \"results_json\": json.dumps({\"equity\": {...}, \"girr_swaps\": {...}}),\n    \"logs_txt\": \"...stdout...\",\n    \"meta_json\": json.dumps({\"app_version\": \"1.0\"}),\n    \"error_txt\": None,\n})\n\n# Listing (pour une table UI)\nruns = list_runs(limit=50, status=\"ok\")\n\n# Lecture complète (pour afficher détails + bouton Restaurer)\nrec = get_run(run_id)\nprint(rec[\"k_total\"], rec[\"snapshot_json\"][:80])\n```",
    "notes": "- **Emplacement DB** : `db_path()` crée/ouvre `frtb_history.sqlite3` à côté du code (même dossier que `app.py` / `ui_common.py`)."
  }
}
